# 이미지 분류

> 출처 : https://www.tensorflow.org/tutorials/images/classification

## 꽃 이미지 분류하기

### 1. 라이브러리 로드

```python
import matplotlib.pyplot as plt
import numpy as np
import os
import PIL
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers, datasets
from tensorflow.keras.models import Sequential
```

### 2. 데이터셋 로드

```python
# 외부망 연결
import pathlib
dataset_url = "https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz"
data_dir = tf.keras.utils.get_file('flower_photos', origin=dataset_url, untar=True)
data_dir = pathlib.Path(data_dir)

# 내부망일 경우
# 경로에 맞게 이동후 압축풀기
import pathlib
path = r'C:\Users\S1SECOM\.keras\datasets'
data_dir = pathlib.Path(path + '\\' + 'flower_photos')
```

- 5개의 하위 디렉토리와 약 3700장의 사진이 있음.

```python
'''
flower_photo/
  daisy/
  dandelion/
  roses/
  sunflowers/
  tulips/
'''
image_count = len(list(data_dir.glob('*/*.jpg')))
print(image_count)	# 3670
```

- 다운로드한 이미지 확인

  ```python
  roses = list(data_dir.glob('roses/*'))
  PIL.Image.open(str(roses[0]))
  ```

  ![image-20210315164501575](이미지 분류.assets/image-20210315164501575.png)

### 3. keras.preprocessing을 사용하여 로드하기 - 데이터세트 만들기

-  [image_dataset_from_directory](https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image_dataset_from_directory) 유틸리티를 사용하여 이미지를 디스크에서 로드

1. 매개변수 정의

   ```python
   batch_size = 32
   img_height = 180
   img_width = 180
   ```

2. 검증 분할

   - 훈련에 이미지의 80%를 사용하고 검증에 20%를 사용

       ```python
       # 훈련 데이터
       train_ds = tf.keras.preprocessing.image_dataset_from_directory(
         data_dir,
         validation_split=0.2,
         subset="training",
         seed=123,
         image_size=(img_height, img_width),
         batch_size=batch_size
       )
       # Found 3670 files belonging to 5 classes.
       # Using 2936 files for training.
       ```
       
       ```python
       # 검증 데이터
       val_ds = tf.keras.preprocessing.image_dataset_from_directory(
         data_dir,
         validation_split=0.2,
         subset="validation",
         seed=123,
         image_size=(img_height, img_width),
         batch_size=batch_size
       )
       # Found 3670 files belonging to 5 classes.
       # Using 734 files for validation.
       ```
       
   - 클래스 네임

       ```python
       class_names = train_ds.class_names
       print(class_names)	# ['daisy', 'dandelion', 'roses', 'sunflowers', 'tulips']
       ```


### 4. 데이터 시각화 하기

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 10))
for images, labels in train_ds.take(1):
  for i in range(9):
    ax = plt.subplot(3, 3, i + 1)
    plt.imshow(images[i].numpy().astype("uint8"))
    plt.title(class_names[labels[i]])
    plt.axis("off")
```

```python
for image_batch, labels_batch in train_ds:
  print(image_batch.shape)
	# (32, 180, 180, 3) - 180x180x3 형상의 32개 이미지 묶음 (마지막 차원은 색상 채널 RGB)
  print(labels_batch.shape)   # (32,) - 32개 이미지에 해당하는 레이블
  break
# image_batch 및 labels_batch 텐서에서 .numpy()를 호출하여 이를 numpy.ndarray로 변환할 수 있습니다.
```

### 5. 성능을 높이도록 데이터세트 구성하기

```python
AUTOTUNE = tf.data.experimental.AUTOTUNE

train_ds = train_ds.cache().shuffle(1000).prefetch(buffer_size=AUTOTUNE)
val_ds = val_ds.cache().prefetch(buffer_size=AUTOTUNE)
```

- `tf.data.Dataset.cache`
  - 데이터셋을 메모리 또는 로컬 저장소에 캐시 - 각 에포크 동안 실행되는 일부 작업(파일 열기 및 데이터 읽기 등)이 저장
  - 데이터셋을 캐시할 때, `cache` 이전의 변환(파일 열기 및 데이터 읽기와 같은)은 첫 번째 에포크 동안에만 실행됩니다. 다음 에포크에는 `cache` 변환에 의해 캐시된 데이터를 재사용

- `tf.data.Dataset.prefetch` 
  - 데이터가 소비되는 시간과 데이터가 생성되는 시간 간의 의존성을 줄일 수 있음.
  - 백그라운드 스레드와 내부 버퍼를 사용하여 요청된 시간 전에 입력 데이터셋에서 요소를 가져옵니다.
  - 가져올 요소의 수 : buffer_size
    - `tf.data.experimental.AUTOTUNE` - tf.data 런타임이 실행 시에 동적으로 값을 조정

### 6. 데이터 표준화 하기
- RGB 채널 값은 `[0, 255]` 범위에 있으므로, `Rescaling` 레이어를 사용하여 값이 `[0, 1]`에 있도록 표준화

    ```python
    normalization_layer = layers.experimental.preprocessing.Rescaling(1./255)
    ```

- 레이어를 사용하는 방법
  1. map을 호출하여 데이터세트에 레이어를 적용
  2. 모델 정의 내에 레이어를 포함하여 배포를 단순화

    ```python
  # 1번 사용법에 대한 코드 / 이후 코드 진행은 2번방법으로 진행
  normalized_ds = train_ds.map(lambda x, y: (normalization_layer(x), y))
  image_batch, labels_batch = next(iter(normalized_ds))
  first_image = image_batch[0]
  # Notice the pixels values are now in `[0,1]`.
  print(np.min(first_image), np.max(first_image))	  # 0.0 1.0
    ```

### 7. 모델 만들기

- 최대 풀 레이어가 있는 3개의 컨볼루션 블록으로 구성
- `relu` 활성화 함수에 의해 활성화되는 128개의 단위가 있는 완전히 연결된 레이어

```python
num_classes = 5

model = Sequential([
  layers.experimental.preprocessing.Rescaling(1./255, input_shape=(img_height, img_width, 3)),
  layers.Conv2D(16, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Conv2D(32, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Conv2D(64, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Flatten(),
  layers.Dense(128, activation='relu'),
  layers.Dense(num_classes)
])
```

### 8. 모델 컴파일 및 요약

```python
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])
model.summary()
```

<img src="이미지 분류.assets/image-20210315171420862.png" alt="image-20210315171420862" style="zoom:80%;" />

### 9. 모델 훈련 및 결과 시각화

```python
epochs=10
history = model.fit(
  train_ds,	# 훈련 데이터
  validation_data=val_ds,  # 검증 데이터
  epochs=epochs
)
```

<img src="이미지 분류.assets/image-20210315171515180.png" alt="image-20210315171515180" style="zoom:80%;" />

```python
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss=history.history['loss']
val_loss=history.history['val_loss']

epochs_range = range(epochs)

plt.figure(figsize=(8, 8))
plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.title('Training and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.title('Training and Validation Loss')
plt.show()
```

<img src="이미지 분류.assets/image-20210315171536650.png" alt="image-20210315171536650" style="zoom:80%;" />

- 훈련 정확성과 검증 정확성은 큰 차이가 있으며, 모델은 검증 세트에서 약 60%의 정확성까지만 도달
  - 전반적인 성능을 향상 필요 !!

---

## 성능향상

### 1. 과대적합 (overfitting)

> 일정 에포크 동안 훈련하면 검증 세트에서 모델 성능이 최고점에 도달한 다음 감소하기 시작한 것

- 일반적으로 훈련 예제가 적을 때 발생

- 과대적합을 막는 방법
  1. 더 많은 훈련 데이터를 사용하는 것
     - 데이터 증강
  2. 규제(regularization)와 같은 기법을 사용하는 것
     - 모델이 저장할 수 있는 정보의 양과 종류에 제약을 부과하는 방법
     - 가중치 규제, 드롭아웃(dropout)

### 1.1. 과소적합(underfitting)

> 테스트 세트의 성능이 향상될 여지가 아직 있을 때

- 모델이 너무 단순하거나, 규제가 너무 많거나, 그냥 단순히 충분히 오래 훈련하지 않는 경우
- 즉 네트워크가 훈련 세트에서 적절한 패턴을 학습하지 못했다는 뜻

### 2. 데이터 증강

> 증강한 다음 믿을 수 있는 이미지를 생성하는 임의 변환을 사용하는 방법으로 기존 예제에서 추가 훈련 데이터를 생성하는 접근법

```python
data_augmentation = keras.Sequential(
  [
    layers.experimental.preprocessing.RandomFlip("horizontal", input_shape=(img_height, img_width, 3)),
    layers.experimental.preprocessing.RandomRotation(0.1),
    layers.experimental.preprocessing.RandomZoom(0.1),
  ]
)
# numpy NotImplementedError 발생시 numpy 버전 1.20 -> 1.19 로 다운그레이드
```

```python
plt.figure(figsize=(10, 10))
for images, _ in train_ds.take(1):
  for i in range(9):
    augmented_images = data_augmentation(images)
    ax = plt.subplot(3, 3, i + 1)
    plt.imshow(augmented_images[0].numpy().astype("uint8"))
    plt.axis("off")
```

<img src="이미지 분류.assets/image-20210315172615310.png" alt="image-20210315172615310" style="zoom: 50%;" />

### 3. 드롭다운

> 신경망을 학습시키는 데 유용한 정규화 형태

- 단일 경사 스텝이 일어날 때마다 특정 네트워크 레이어의 유닛을 고정된 개수만큼 무작위로 선택하여 삭제

- 보통 0.2에서 0.5 사이를 사용

```python
model = Sequential([
  data_augmentation,	# 데이터 증강
  layers.experimental.preprocessing.Rescaling(1./255),	# 데이터 표준화
  layers.Conv2D(16, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Conv2D(32, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Conv2D(64, 3, padding='same', activation='relu'),
  layers.MaxPooling2D(),
  layers.Dropout(0.2),	# Dropdown
  layers.Flatten(),
  layers.Dense(128, activation='relu'),
  layers.Dense(num_classes)	# num_classes = 5
])
```

```python
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])
model.summary()
```

<img src="이미지 분류.assets/image-20210315173138954.png" alt="image-20210315173138954" style="zoom:80%;" />

```python
epochs = 15
history = model.fit(
  train_ds,
  validation_data=val_ds,
  epochs=epochs
)
```

<img src="이미지 분류.assets/image-20210315173159974.png" alt="image-20210315173159974" style="zoom:80%;" />

```python
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

epochs_range = range(epochs)

plt.figure(figsize=(8, 8))
plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.title('Training and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.title('Training and Validation Loss')
plt.show()
```

- 데이터 증강 및 드롭아웃을 적용한 후, 이전보다 과대적합이 줄어들고 훈련 및 검증 정확성이 더 가깝게 조정

<img src="이미지 분류.assets/image-20210315173223561.png" alt="image-20210315173223561" style="zoom:67%;" />

- 새로운 데이터로 예측

  - 모델을 사용하여 훈련 또는 검증 세트에 포함되지 않은 이미지를 분류
  - 데이터 증강 및 드롭아웃 레이어는 추론 시 비활성화 됨

  ```python
  ''' 외부망
  sunflower_url = "https://storage.googleapis.com/download.tensorflow.org/example_images/592px-Red_sunflower.jpg"
  sunflower_path = tf.keras.utils.get_file('Red_sunflower', origin=sunflower_url)
  '''
  # 내부망
  path = r'C:\Users\S1SECOM\.keras\datasets'
  sunflower_path = pathlib.Path(path + '\\' + 'Red_sunflower.jpg')
  
  img = keras.preprocessing.image.load_img(
      sunflower_path, target_size=(img_height, img_width)
  )
  img_array = keras.preprocessing.image.img_to_array(img)
  img_array = tf.expand_dims(img_array, 0) # Create a batch
  
  predictions = model.predict(img_array)
  score = tf.nn.softmax(predictions[0])
  
  print(
      "This image most likely belongs to {} with a {:.2f} percent confidence."
      .format(class_names[np.argmax(score)], 100 * np.max(score))
  )
  # This image most likely belongs to sunflowers with a 94.66 percent confidence.
  ```

  